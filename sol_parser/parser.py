"""Parser for SOL (Scouting-NL) output

<<<<<<< HEAD
Parser accepts a single positional argument: reference to a csv file
=======
Parser class for csv files generated by the Scouts Online (SOL) program
provided by the Dutch Scouts Organisation; Scouting NL.
>>>>>>> memberships

Class contains functions to calculate the current age and the age at a
'turnover' date; when a certain age is reached at the the turnover date the
scout has to migrate to the next group.
"""

from csv import DictReader
from datetime import date
from dateutil.relativedelta import relativedelta
from operator import itemgetter
from pprint import pprint
from .scout import Scout

import unicodedata


def normalize(text):
    """Normalize a string to lowercase.

    To used when performing string comparisson
    """
    return unicodedata.normalize("NFKD", text.lower())


def str_check(str=''):
    for char in [' ', '/', '-']:
        if char in str:
            str = str.replace(char, '_')
    return str


class ScoutsCollection():
    """Parser class for SOL csv output

    Attributes:
        migration_date (datetime): Migration date used to calculate which scouts should transfer to the next group when the season ends (at the migration date)
        objLeden (dict): Dictionary containig all members from csvfile
    """

    def __init__(self, csvfile):
        """Initiate class

        Args:
            csvfile (TYPE): Input file to parse (csv format)
        """
        self.addresses = set()
        self.names = set()
        self.objLeden = list()

        # self.migration_date = self.migration_date()
        # self.season_start, self.season_end = self.season()

        with open(csvfile) as csvfile:
            try:
                reader = DictReader(csvfile)
                reader.fieldnames = [normalize(str_check(fn)) for fn in reader.fieldnames]
                pprint(reader.fieldnames)
                for row in reader:
                    # self.members.add(Scout(row, self.migration_date))
                    member = Scout(row)
                    
                    member.migration_date = self.calc_migration_date()
                    member.season_start, member.season_end = self.season()
                    member.m_leeftijd = member.__calc_age__(refdate=member.migration_date)
                    
                    self.names.add(member.naam)
                    self.addresses.add(member.lid_adres)
                    self.objLeden.append(member)
            finally:
                csvfile.close()

    def __iter__(self):
        """Summary.

        Returns:
            TYPE: Description
        """
        return iter(self.objLeden)

    def calc_migration_date(self):
        """Summary.

        Returns:
            TYPE: Description
        """
        # setup date for checking age
        today = date.today()
        if today.month >= 9 and today.day >= 1:
            # replace day and month for given values
            # Increases current year with 1
            self.migration_date = today + \
                relativedelta(day=1, month=9, years=1)
        else:
            # replace day and month for given values
            # Keeps the year equal to he current year
            self.migration_date = today + relativedelta(day=1, month=9)

        return self.migration_date

    def season(self):
        """Summary.

        Returns:
            TYPE: Description
        """
        # Return start and End year of the current season
        today = date.today()
        if today.month >= 9 and today.day >= 1:
            return (today.year, today.year+1)
        else:
            return (today.year-1, today.year)

    def filter_age(self, age):
        """Summary.

        Returns:
            TYPE: Description

        Args:
            age (TYPE): Description
        """
        filtered = dict()
        count = 0

        for y in self.objLeden:
            if self.objLeden[y]['chk_leeftijd'] >= age and self.objLeden[y]['functie'] == "jeugdlid *":
                count = count + 1
                filtered[self.objLeden[y]['lidnummer']] = self.objLeden[y]
        return filtered, count

    def list(self):
        """Summary.

        Returns:
            TYPE: Description
        """
        return self.objLeden

    def group(self):
        ret = dict()
        for a in self.addresses:
            ret[a] = sorted(list(filter(lambda d: getattr(d, 'lid_adres') == a, self.objLeden)),
                            key=lambda x: x.born,
                            reverse=False)
        return ret

